local ClassesToHook = {
	RemoteEvent = "OnClientEvent",
	RemoteFunction = "OnClientInvoke",
	UnreliableRemoteEvent = "OnClientEvent",
	BindableEvent = "Event",
	BindableFunction = "OnInvoke",
}

type InstancesToHook = RemoteEvent | UnreliableRemoteEvent | RemoteFunction | BindableEvent | BindableFunction
type MethodsToHook = "OnClientEvent" | "OnClientInvoke" | "Event" | "OnInvoke"

local LogConnectionFunctions = {}
local SignalMapping = setmetatable({}, { __mode = "kv" })

--[[
	返回调用函数的脚本所在的行号，使用 `debug.info`

	@return number 返回调用脚本的行号
]]
local function getcallingline()
	for i = 4, 10 do
		local Source, Line = debug.info(i, "sl")
		if not Source then
			break
		end

		if Source == "[C]" then
			continue
		end

		return Line
	end

	return debug.info(4, "l")
end

--[[
	单独记录一次接收到的远程调用。

	@param Instance 被调用的实例
	@param Method 被调用的方法 (例如 "OnClientEvent")
	@param Function 被调用的函数，如果有的话
	@param Info 关于调用的信息，包括参数和来源。可以为 nil
	@param ... 从服务端传给客户端的参数
	@return boolean 如果调用被拦截则返回 true，否则返回 false
]]
local function LogRemote(
	Instance: InstancesToHook,
	Method: MethodsToHook,
	Function: (...any) -> ...any,
	Info: {
		Arguments: { [number]: any, n: number },
		Time: string,
		Origin: Instance,
		Function: (...any) -> ...any,
		Line: number,
		IsExecutor: boolean,
	} | nil,
	...
)
	if not wax.shared.ShouldIgnore(Instance, getcallingscript()) and not LogConnectionFunctions[Function] then
		local Log = wax.shared.Logs.Incoming[Instance]
		if not Log then
			Log = wax.shared.NewLog(Instance, "Incoming", Method, getcallingscript())
		end

		if Log.Blocked then
			return true
		elseif not Log.Ignored then
			local CallInfo = Info
				or {
					Arguments = table.pack(...),
					Time = os.date("%X"),
					Origin = getcallingscript(),
					Function = Function,
					Line = getcallingline(),
					IsExecutor = checkcaller(),
				}
			Log:Call(CallInfo)
		end
	end

	return false
end

--[[
	创建一个函数，用于传递给 `Connect`，它会记录所有进入的调用。  
	同时会将该函数添加到忽略列表 (`LogConnectionFunctions`)，以避免不必要的重复记录。
	
	@param Instance 要记录的实例
	@param Method 要记录的方法 (例如 "OnClientEvent")
	@return function 返回一个函数，该函数会记录所有该实例和方法的调用
]]
local function CreateConnectionFunction(Instance: InstancesToHook, Method: MethodsToHook)
	local ConnectionFunction = function(...)
		for _, Connection in pairs(getconnections((Instance :: any)[Method])) do
			if Connection.ForeignState then
				continue
			end

			local Function = typeof(Connection.Function) == "function" and Connection.Function or nil
			local Thread = Connection.Thread

			local Origin = nil

			if Thread and getscriptfromthread then
				Origin = getscriptfromthread(Thread)
			elseif Function then
				-- ts（ThreadScript）不可靠，因为可能有人直接把全局 script 置为 nil
				-- 如果 debug.getinfo(Function).source 或 debug.info(Function, "s") 能返回 Instance 就好了...

				local Script = rawget(getfenv(Function), "script")
				if typeof(Script) == "Instance" then
					Origin = Script
				end
			end

			LogRemote(Instance, Method, Function, {
				Arguments = table.pack(...),
				Time = os.date("%X"),
				Origin = Origin,
				Function = Function,
				Line = nil,
				IsExecutor = Function and isexecutorclosure(Function) or false,
			}, ...)
		end
	end

	LogConnectionFunctions[ConnectionFunction] = true
	return ConnectionFunction
end

--[[
	处理某个实例的日志挂钩设置

	@param Instance 要处理的实例
]]
local function HandleInstance(Instance: any)
	if not ClassesToHook[Instance.ClassName] or Instance == wax.shared.Communicator then
		return
	end

	local Method = ClassesToHook[Instance.ClassName]

	if Instance.ClassName == "RemoteEvent" or Instance.ClassName == "UnreliableRemoteEvent" then
		wax.shared.Connect(Instance.OnClientEvent:Connect(CreateConnectionFunction(Instance, Method)))

		SignalMapping[Instance.OnClientEvent] = Instance
	elseif Instance.ClassName == "BindableEvent" then
		wax.shared.Connect(Instance.Event:Connect(CreateConnectionFunction(Instance, Method)))

		SignalMapping[Instance.Event] = Instance
	elseif Instance.ClassName == "RemoteFunction" or Instance.ClassName == "BindableFunction" then
		local Success, Callback = pcall(getcallbackvalue, Instance, Method)
		local IsCallable = (
			typeof(Callback) == "function"
			or wax.shared.getrawmetatable(Callback) ~= nil and typeof(wax.shared.getrawmetatable(Callback)["__call"]) == "function"
			or false
		)

		if not Success or not IsCallable then
			return
		end

		Instance[Method] = function(...)
			if LogRemote(Instance, Method, Callback, nil, ...) then
				return
			end

			return Callback(...)
		end
	end
end

wax.shared.Connect(game.DescendantAdded:Connect(HandleInstance))

-- getinstances() 不可靠，漏掉了一些实例... ts 兄弟真坑
local CategoryToSearch = { game:GetDescendants() }
if wax.shared.ExecutorSupport["getnilinstances"].IsWorking then
	table.insert(CategoryToSearch, getnilinstances())
end

for _, Category in CategoryToSearch do
	for _, Instance in pairs(Category) do
		HandleInstance(Instance)
	end
end

wax.shared.NewIndexHook = wax.shared.Hooking.HookMetaMethod(
	game,
	"__newindex",
	wax.shared.newcclosure(function(...)
		local self, key, value = ...

		if typeof(self) ~= "Instance" or not ClassesToHook[self.ClassName] then
			return wax.shared.NewIndexHook(...)
		end

		if self.ClassName == "RemoteFunction" or self.ClassName == "BindableFunction" then
			local Method = ClassesToHook[self.ClassName]

			local IsCallable = (
				typeof(value) == "function"
				or wax.shared.getrawmetatable(value) ~= nil and typeof(wax.shared.getrawmetatable(value)["__call"]) == "function"
				or false
			)

			if key == Method and IsCallable then
				return wax.shared.NewIndexHook(self, key, function(...)
					if LogRemote(self :: InstancesToHook, Method, value, nil, ...) then
						return
					end

					return value(...)
				end)
			end
		end

		return wax.shared.NewIndexHook(...)
	end)
)

local ConnectionKeys = {
	"Connect",
	"ConnectParallel",
	"connect",
	"connectParallel",
	"once",
	"Once",
}

local SignalMetatable = wax.shared.getrawmetatable(Instance.new("Part").Touched)
wax.shared.Hooks[SignalMetatable.__index] = wax.shared.Hooking.HookFunction(SignalMetatable.__index, function(...)
	local self, key = ...

	if table.find(ConnectionKeys, key) then
		local Instance = SignalMapping[self]
		local Connect = wax.shared.Hooks[SignalMetatable.__index](...)

		if not Instance then
			return Connect
		end

		local Method = ClassesToHook[Instance.ClassName]
		wax.shared.Hooks[Connect] = wax.shared.Hooking.HookFunction(
			Connect,
			wax.shared.newcclosure(function(...)
				local _self, callback = ...

				local Result = table.pack(wax.shared.Hooks[Connect](...))
				local Log = wax.shared.Logs.Incoming[Instance]

				if Log and Log.Blocked then
					for _, Connection in pairs(getconnections(Instance[Method])) do
						if not Connection.ForeignState and Connection.Function ~= callback then
							continue
						end

						Connection:Disable()
					end
				end

				return table.unpack(Result, 1, Result.n)
			end)
		)

		return Connect
	end

	return wax.shared.Hooks[SignalMetatable.__index](...)
end)
